// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tracker_pb.proto

#ifndef PROTOBUF_tracker_5fpb_2eproto__INCLUDED
#define PROTOBUF_tracker_5fpb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tracker_5fpb_2eproto();
void protobuf_AssignDesc_tracker_5fpb_2eproto();
void protobuf_ShutdownFile_tracker_5fpb_2eproto();

class OrthoConv;
class Affine2D;
class ProjMat;
class CameraOpt;
class CameraGroup;
class Led;
class TrackerOpt;

enum CameraGroup_CombineStyle {
  CameraGroup_CombineStyle_NONE = 1,
  CameraGroup_CombineStyle_PANOSTITCH = 2,
  CameraGroup_CombineStyle_FULL3D = 3
};
bool CameraGroup_CombineStyle_IsValid(int value);
const CameraGroup_CombineStyle CameraGroup_CombineStyle_CombineStyle_MIN = CameraGroup_CombineStyle_NONE;
const CameraGroup_CombineStyle CameraGroup_CombineStyle_CombineStyle_MAX = CameraGroup_CombineStyle_FULL3D;
const int CameraGroup_CombineStyle_CombineStyle_ARRAYSIZE = CameraGroup_CombineStyle_CombineStyle_MAX + 1;

const ::google::protobuf::EnumDescriptor* CameraGroup_CombineStyle_descriptor();
inline const ::std::string& CameraGroup_CombineStyle_Name(CameraGroup_CombineStyle value) {
  return ::google::protobuf::internal::NameOfEnum(
    CameraGroup_CombineStyle_descriptor(), value);
}
inline bool CameraGroup_CombineStyle_Parse(
    const ::std::string& name, CameraGroup_CombineStyle* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CameraGroup_CombineStyle>(
    CameraGroup_CombineStyle_descriptor(), name, value);
}
// ===================================================================

class OrthoConv : public ::google::protobuf::Message {
 public:
  OrthoConv();
  virtual ~OrthoConv();
  
  OrthoConv(const OrthoConv& from);
  
  inline OrthoConv& operator=(const OrthoConv& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrthoConv& default_instance();
  
  void Swap(OrthoConv* other);
  
  // implements Message ----------------------------------------------
  
  OrthoConv* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrthoConv& from);
  void MergeFrom(const OrthoConv& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float x_min = 1;
  inline bool has_x_min() const;
  inline void clear_x_min();
  static const int kXMinFieldNumber = 1;
  inline float x_min() const;
  inline void set_x_min(float value);
  
  // optional float x_max = 2;
  inline bool has_x_max() const;
  inline void clear_x_max();
  static const int kXMaxFieldNumber = 2;
  inline float x_max() const;
  inline void set_x_max(float value);
  
  // optional float y_min = 3;
  inline bool has_y_min() const;
  inline void clear_y_min();
  static const int kYMinFieldNumber = 3;
  inline float y_min() const;
  inline void set_y_min(float value);
  
  // optional float y_max = 4;
  inline bool has_y_max() const;
  inline void clear_y_max();
  static const int kYMaxFieldNumber = 4;
  inline float y_max() const;
  inline void set_y_max(float value);
  
  // @@protoc_insertion_point(class_scope:OrthoConv)
 private:
  inline void set_has_x_min();
  inline void clear_has_x_min();
  inline void set_has_x_max();
  inline void clear_has_x_max();
  inline void set_has_y_min();
  inline void clear_has_y_min();
  inline void set_has_y_max();
  inline void clear_has_y_max();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_min_;
  float x_max_;
  float y_min_;
  float y_max_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_tracker_5fpb_2eproto();
  friend void protobuf_AssignDesc_tracker_5fpb_2eproto();
  friend void protobuf_ShutdownFile_tracker_5fpb_2eproto();
  
  void InitAsDefaultInstance();
  static OrthoConv* default_instance_;
};
// -------------------------------------------------------------------

class Affine2D : public ::google::protobuf::Message {
 public:
  Affine2D();
  virtual ~Affine2D();
  
  Affine2D(const Affine2D& from);
  
  inline Affine2D& operator=(const Affine2D& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Affine2D& default_instance();
  
  void Swap(Affine2D* other);
  
  // implements Message ----------------------------------------------
  
  Affine2D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Affine2D& from);
  void MergeFrom(const Affine2D& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated float coef = 1;
  inline int coef_size() const;
  inline void clear_coef();
  static const int kCoefFieldNumber = 1;
  inline float coef(int index) const;
  inline void set_coef(int index, float value);
  inline void add_coef(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      coef() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_coef();
  
  // @@protoc_insertion_point(class_scope:Affine2D)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< float > coef_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_tracker_5fpb_2eproto();
  friend void protobuf_AssignDesc_tracker_5fpb_2eproto();
  friend void protobuf_ShutdownFile_tracker_5fpb_2eproto();
  
  void InitAsDefaultInstance();
  static Affine2D* default_instance_;
};
// -------------------------------------------------------------------

class ProjMat : public ::google::protobuf::Message {
 public:
  ProjMat();
  virtual ~ProjMat();
  
  ProjMat(const ProjMat& from);
  
  inline ProjMat& operator=(const ProjMat& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjMat& default_instance();
  
  void Swap(ProjMat* other);
  
  // implements Message ----------------------------------------------
  
  ProjMat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProjMat& from);
  void MergeFrom(const ProjMat& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated float coef = 1;
  inline int coef_size() const;
  inline void clear_coef();
  static const int kCoefFieldNumber = 1;
  inline float coef(int index) const;
  inline void set_coef(int index, float value);
  inline void add_coef(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      coef() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_coef();
  
  // @@protoc_insertion_point(class_scope:ProjMat)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< float > coef_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_tracker_5fpb_2eproto();
  friend void protobuf_AssignDesc_tracker_5fpb_2eproto();
  friend void protobuf_ShutdownFile_tracker_5fpb_2eproto();
  
  void InitAsDefaultInstance();
  static ProjMat* default_instance_;
};
// -------------------------------------------------------------------

class CameraOpt : public ::google::protobuf::Message {
 public:
  CameraOpt();
  virtual ~CameraOpt();
  
  CameraOpt(const CameraOpt& from);
  
  inline CameraOpt& operator=(const CameraOpt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraOpt& default_instance();
  
  void Swap(CameraOpt* other);
  
  // implements Message ----------------------------------------------
  
  CameraOpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraOpt& from);
  void MergeFrom(const CameraOpt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 serial_number = 2;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 2;
  inline ::google::protobuf::int32 serial_number() const;
  inline void set_serial_number(::google::protobuf::int32 value);
  
  // optional string input_file_name = 3;
  inline bool has_input_file_name() const;
  inline void clear_input_file_name();
  static const int kInputFileNameFieldNumber = 3;
  inline const ::std::string& input_file_name() const;
  inline void set_input_file_name(const ::std::string& value);
  inline void set_input_file_name(const char* value);
  inline void set_input_file_name(const char* value, size_t size);
  inline ::std::string* mutable_input_file_name();
  inline ::std::string* release_input_file_name();
  
  // optional string output_file_name = 4;
  inline bool has_output_file_name() const;
  inline void clear_output_file_name();
  static const int kOutputFileNameFieldNumber = 4;
  inline const ::std::string& output_file_name() const;
  inline void set_output_file_name(const ::std::string& value);
  inline void set_output_file_name(const char* value);
  inline void set_output_file_name(const char* value, size_t size);
  inline ::std::string* mutable_output_file_name();
  inline ::std::string* release_output_file_name();
  
  // optional .OrthoConv ortho_conv = 5;
  inline bool has_ortho_conv() const;
  inline void clear_ortho_conv();
  static const int kOrthoConvFieldNumber = 5;
  inline const ::OrthoConv& ortho_conv() const;
  inline ::OrthoConv* mutable_ortho_conv();
  inline ::OrthoConv* release_ortho_conv();
  
  // optional .Affine2D affine_2d = 6;
  inline bool has_affine_2d() const;
  inline void clear_affine_2d();
  static const int kAffine2DFieldNumber = 6;
  inline const ::Affine2D& affine_2d() const;
  inline ::Affine2D* mutable_affine_2d();
  inline ::Affine2D* release_affine_2d();
  
  // optional .ProjMat proj_mat = 7;
  inline bool has_proj_mat() const;
  inline void clear_proj_mat();
  static const int kProjMatFieldNumber = 7;
  inline const ::ProjMat& proj_mat() const;
  inline ::ProjMat* mutable_proj_mat();
  inline ::ProjMat* release_proj_mat();
  
  // optional int32 led_blur1 = 8;
  inline bool has_led_blur1() const;
  inline void clear_led_blur1();
  static const int kLedBlur1FieldNumber = 8;
  inline ::google::protobuf::int32 led_blur1() const;
  inline void set_led_blur1(::google::protobuf::int32 value);
  
  // optional float led_threshold = 9;
  inline bool has_led_threshold() const;
  inline void clear_led_threshold();
  static const int kLedThresholdFieldNumber = 9;
  inline float led_threshold() const;
  inline void set_led_threshold(float value);
  
  // optional int32 led_blur2 = 10;
  inline bool has_led_blur2() const;
  inline void clear_led_blur2();
  static const int kLedBlur2FieldNumber = 10;
  inline ::google::protobuf::int32 led_blur2() const;
  inline void set_led_blur2(::google::protobuf::int32 value);
  
  // optional int32 body_blur1 = 11;
  inline bool has_body_blur1() const;
  inline void clear_body_blur1();
  static const int kBodyBlur1FieldNumber = 11;
  inline ::google::protobuf::int32 body_blur1() const;
  inline void set_body_blur1(::google::protobuf::int32 value);
  
  // optional float body_threshold = 12;
  inline bool has_body_threshold() const;
  inline void clear_body_threshold();
  static const int kBodyThresholdFieldNumber = 12;
  inline float body_threshold() const;
  inline void set_body_threshold(float value);
  
  // optional int32 body_blur2 = 13;
  inline bool has_body_blur2() const;
  inline void clear_body_blur2();
  static const int kBodyBlur2FieldNumber = 13;
  inline ::google::protobuf::int32 body_blur2() const;
  inline void set_body_blur2(::google::protobuf::int32 value);
  
  // optional int32 led_diameter_px = 14;
  inline bool has_led_diameter_px() const;
  inline void clear_led_diameter_px();
  static const int kLedDiameterPxFieldNumber = 14;
  inline ::google::protobuf::int32 led_diameter_px() const;
  inline void set_led_diameter_px(::google::protobuf::int32 value);
  
  // optional bool background_subtract = 15;
  inline bool has_background_subtract() const;
  inline void clear_background_subtract();
  static const int kBackgroundSubtractFieldNumber = 15;
  inline bool background_subtract() const;
  inline void set_background_subtract(bool value);
  
  // @@protoc_insertion_point(class_scope:CameraOpt)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_input_file_name();
  inline void clear_has_input_file_name();
  inline void set_has_output_file_name();
  inline void clear_has_output_file_name();
  inline void set_has_ortho_conv();
  inline void clear_has_ortho_conv();
  inline void set_has_affine_2d();
  inline void clear_has_affine_2d();
  inline void set_has_proj_mat();
  inline void clear_has_proj_mat();
  inline void set_has_led_blur1();
  inline void clear_has_led_blur1();
  inline void set_has_led_threshold();
  inline void clear_has_led_threshold();
  inline void set_has_led_blur2();
  inline void clear_has_led_blur2();
  inline void set_has_body_blur1();
  inline void clear_has_body_blur1();
  inline void set_has_body_threshold();
  inline void clear_has_body_threshold();
  inline void set_has_body_blur2();
  inline void clear_has_body_blur2();
  inline void set_has_led_diameter_px();
  inline void clear_has_led_diameter_px();
  inline void set_has_background_subtract();
  inline void clear_has_background_subtract();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 serial_number_;
  ::std::string* input_file_name_;
  ::std::string* output_file_name_;
  ::OrthoConv* ortho_conv_;
  ::Affine2D* affine_2d_;
  ::ProjMat* proj_mat_;
  ::google::protobuf::int32 led_blur1_;
  float led_threshold_;
  ::google::protobuf::int32 led_blur2_;
  ::google::protobuf::int32 body_blur1_;
  float body_threshold_;
  ::google::protobuf::int32 body_blur2_;
  ::google::protobuf::int32 led_diameter_px_;
  bool background_subtract_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];
  
  friend void  protobuf_AddDesc_tracker_5fpb_2eproto();
  friend void protobuf_AssignDesc_tracker_5fpb_2eproto();
  friend void protobuf_ShutdownFile_tracker_5fpb_2eproto();
  
  void InitAsDefaultInstance();
  static CameraOpt* default_instance_;
};
// -------------------------------------------------------------------

class CameraGroup : public ::google::protobuf::Message {
 public:
  CameraGroup();
  virtual ~CameraGroup();
  
  CameraGroup(const CameraGroup& from);
  
  inline CameraGroup& operator=(const CameraGroup& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraGroup& default_instance();
  
  void Swap(CameraGroup* other);
  
  // implements Message ----------------------------------------------
  
  CameraGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraGroup& from);
  void MergeFrom(const CameraGroup& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef CameraGroup_CombineStyle CombineStyle;
  static const CombineStyle NONE = CameraGroup_CombineStyle_NONE;
  static const CombineStyle PANOSTITCH = CameraGroup_CombineStyle_PANOSTITCH;
  static const CombineStyle FULL3D = CameraGroup_CombineStyle_FULL3D;
  static inline bool CombineStyle_IsValid(int value) {
    return CameraGroup_CombineStyle_IsValid(value);
  }
  static const CombineStyle CombineStyle_MIN =
    CameraGroup_CombineStyle_CombineStyle_MIN;
  static const CombineStyle CombineStyle_MAX =
    CameraGroup_CombineStyle_CombineStyle_MAX;
  static const int CombineStyle_ARRAYSIZE =
    CameraGroup_CombineStyle_CombineStyle_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CombineStyle_descriptor() {
    return CameraGroup_CombineStyle_descriptor();
  }
  static inline const ::std::string& CombineStyle_Name(CombineStyle value) {
    return CameraGroup_CombineStyle_Name(value);
  }
  static inline bool CombineStyle_Parse(const ::std::string& name,
      CombineStyle* value) {
    return CameraGroup_CombineStyle_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // repeated .CameraOpt cam = 1;
  inline int cam_size() const;
  inline void clear_cam();
  static const int kCamFieldNumber = 1;
  inline const ::CameraOpt& cam(int index) const;
  inline ::CameraOpt* mutable_cam(int index);
  inline ::CameraOpt* add_cam();
  inline const ::google::protobuf::RepeatedPtrField< ::CameraOpt >&
      cam() const;
  inline ::google::protobuf::RepeatedPtrField< ::CameraOpt >*
      mutable_cam();
  
  // optional .CameraGroup.CombineStyle combine = 2;
  inline bool has_combine() const;
  inline void clear_combine();
  static const int kCombineFieldNumber = 2;
  inline ::CameraGroup_CombineStyle combine() const;
  inline void set_combine(::CameraGroup_CombineStyle value);
  
  // optional string label = 3;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 3;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  
  // @@protoc_insertion_point(class_scope:CameraGroup)
 private:
  inline void set_has_combine();
  inline void clear_has_combine();
  inline void set_has_label();
  inline void clear_has_label();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::CameraOpt > cam_;
  ::std::string* label_;
  int combine_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_tracker_5fpb_2eproto();
  friend void protobuf_AssignDesc_tracker_5fpb_2eproto();
  friend void protobuf_ShutdownFile_tracker_5fpb_2eproto();
  
  void InitAsDefaultInstance();
  static CameraGroup* default_instance_;
};
// -------------------------------------------------------------------

class Led : public ::google::protobuf::Message {
 public:
  Led();
  virtual ~Led();
  
  Led(const Led& from);
  
  inline Led& operator=(const Led& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Led& default_instance();
  
  void Swap(Led* other);
  
  // implements Message ----------------------------------------------
  
  Led* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Led& from);
  void MergeFrom(const Led& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float x_pos = 1;
  inline bool has_x_pos() const;
  inline void clear_x_pos();
  static const int kXPosFieldNumber = 1;
  inline float x_pos() const;
  inline void set_x_pos(float value);
  
  // optional float y_pos = 2;
  inline bool has_y_pos() const;
  inline void clear_y_pos();
  static const int kYPosFieldNumber = 2;
  inline float y_pos() const;
  inline void set_y_pos(float value);
  
  // optional float z_pos = 3;
  inline bool has_z_pos() const;
  inline void clear_z_pos();
  static const int kZPosFieldNumber = 3;
  inline float z_pos() const;
  inline void set_z_pos(float value);
  
  // @@protoc_insertion_point(class_scope:Led)
 private:
  inline void set_has_x_pos();
  inline void clear_has_x_pos();
  inline void set_has_y_pos();
  inline void clear_has_y_pos();
  inline void set_has_z_pos();
  inline void clear_has_z_pos();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  float x_pos_;
  float y_pos_;
  float z_pos_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_tracker_5fpb_2eproto();
  friend void protobuf_AssignDesc_tracker_5fpb_2eproto();
  friend void protobuf_ShutdownFile_tracker_5fpb_2eproto();
  
  void InitAsDefaultInstance();
  static Led* default_instance_;
};
// -------------------------------------------------------------------

class TrackerOpt : public ::google::protobuf::Message {
 public:
  TrackerOpt();
  virtual ~TrackerOpt();
  
  TrackerOpt(const TrackerOpt& from);
  
  inline TrackerOpt& operator=(const TrackerOpt& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TrackerOpt& default_instance();
  
  void Swap(TrackerOpt* other);
  
  // implements Message ----------------------------------------------
  
  TrackerOpt* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrackerOpt& from);
  void MergeFrom(const TrackerOpt& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .CameraGroup group = 1;
  inline int group_size() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 1;
  inline const ::CameraGroup& group(int index) const;
  inline ::CameraGroup* mutable_group(int index);
  inline ::CameraGroup* add_group();
  inline const ::google::protobuf::RepeatedPtrField< ::CameraGroup >&
      group() const;
  inline ::google::protobuf::RepeatedPtrField< ::CameraGroup >*
      mutable_group();
  
  // optional int32 max_n_cams = 2;
  inline bool has_max_n_cams() const;
  inline void clear_max_n_cams();
  static const int kMaxNCamsFieldNumber = 2;
  inline ::google::protobuf::int32 max_n_cams() const;
  inline void set_max_n_cams(::google::protobuf::int32 value);
  
  // optional string timer = 3;
  inline bool has_timer() const;
  inline void clear_timer();
  static const int kTimerFieldNumber = 3;
  inline const ::std::string& timer() const;
  inline void set_timer(const ::std::string& value);
  inline void set_timer(const char* value);
  inline void set_timer(const char* value, size_t size);
  inline ::std::string* mutable_timer();
  inline ::std::string* release_timer();
  
  // optional int32 n_led = 4;
  inline bool has_n_led() const;
  inline void clear_n_led();
  static const int kNLedFieldNumber = 4;
  inline ::google::protobuf::int32 n_led() const;
  inline void set_n_led(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:TrackerOpt)
 private:
  inline void set_has_max_n_cams();
  inline void clear_has_max_n_cams();
  inline void set_has_timer();
  inline void clear_has_timer();
  inline void set_has_n_led();
  inline void clear_has_n_led();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::CameraGroup > group_;
  ::std::string* timer_;
  ::google::protobuf::int32 max_n_cams_;
  ::google::protobuf::int32 n_led_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_tracker_5fpb_2eproto();
  friend void protobuf_AssignDesc_tracker_5fpb_2eproto();
  friend void protobuf_ShutdownFile_tracker_5fpb_2eproto();
  
  void InitAsDefaultInstance();
  static TrackerOpt* default_instance_;
};
// ===================================================================


// ===================================================================

// OrthoConv

// optional float x_min = 1;
inline bool OrthoConv::has_x_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrthoConv::set_has_x_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrthoConv::clear_has_x_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrthoConv::clear_x_min() {
  x_min_ = 0;
  clear_has_x_min();
}
inline float OrthoConv::x_min() const {
  return x_min_;
}
inline void OrthoConv::set_x_min(float value) {
  set_has_x_min();
  x_min_ = value;
}

// optional float x_max = 2;
inline bool OrthoConv::has_x_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrthoConv::set_has_x_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrthoConv::clear_has_x_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrthoConv::clear_x_max() {
  x_max_ = 0;
  clear_has_x_max();
}
inline float OrthoConv::x_max() const {
  return x_max_;
}
inline void OrthoConv::set_x_max(float value) {
  set_has_x_max();
  x_max_ = value;
}

// optional float y_min = 3;
inline bool OrthoConv::has_y_min() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrthoConv::set_has_y_min() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrthoConv::clear_has_y_min() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrthoConv::clear_y_min() {
  y_min_ = 0;
  clear_has_y_min();
}
inline float OrthoConv::y_min() const {
  return y_min_;
}
inline void OrthoConv::set_y_min(float value) {
  set_has_y_min();
  y_min_ = value;
}

// optional float y_max = 4;
inline bool OrthoConv::has_y_max() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrthoConv::set_has_y_max() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrthoConv::clear_has_y_max() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrthoConv::clear_y_max() {
  y_max_ = 0;
  clear_has_y_max();
}
inline float OrthoConv::y_max() const {
  return y_max_;
}
inline void OrthoConv::set_y_max(float value) {
  set_has_y_max();
  y_max_ = value;
}

// -------------------------------------------------------------------

// Affine2D

// repeated float coef = 1;
inline int Affine2D::coef_size() const {
  return coef_.size();
}
inline void Affine2D::clear_coef() {
  coef_.Clear();
}
inline float Affine2D::coef(int index) const {
  return coef_.Get(index);
}
inline void Affine2D::set_coef(int index, float value) {
  coef_.Set(index, value);
}
inline void Affine2D::add_coef(float value) {
  coef_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
Affine2D::coef() const {
  return coef_;
}
inline ::google::protobuf::RepeatedField< float >*
Affine2D::mutable_coef() {
  return &coef_;
}

// -------------------------------------------------------------------

// ProjMat

// repeated float coef = 1;
inline int ProjMat::coef_size() const {
  return coef_.size();
}
inline void ProjMat::clear_coef() {
  coef_.Clear();
}
inline float ProjMat::coef(int index) const {
  return coef_.Get(index);
}
inline void ProjMat::set_coef(int index, float value) {
  coef_.Set(index, value);
}
inline void ProjMat::add_coef(float value) {
  coef_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
ProjMat::coef() const {
  return coef_;
}
inline ::google::protobuf::RepeatedField< float >*
ProjMat::mutable_coef() {
  return &coef_;
}

// -------------------------------------------------------------------

// CameraOpt

// optional int32 id = 1;
inline bool CameraOpt::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraOpt::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraOpt::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraOpt::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CameraOpt::id() const {
  return id_;
}
inline void CameraOpt::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 serial_number = 2;
inline bool CameraOpt::has_serial_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraOpt::set_has_serial_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraOpt::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraOpt::clear_serial_number() {
  serial_number_ = 0;
  clear_has_serial_number();
}
inline ::google::protobuf::int32 CameraOpt::serial_number() const {
  return serial_number_;
}
inline void CameraOpt::set_serial_number(::google::protobuf::int32 value) {
  set_has_serial_number();
  serial_number_ = value;
}

// optional string input_file_name = 3;
inline bool CameraOpt::has_input_file_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraOpt::set_has_input_file_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraOpt::clear_has_input_file_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraOpt::clear_input_file_name() {
  if (input_file_name_ != &::google::protobuf::internal::kEmptyString) {
    input_file_name_->clear();
  }
  clear_has_input_file_name();
}
inline const ::std::string& CameraOpt::input_file_name() const {
  return *input_file_name_;
}
inline void CameraOpt::set_input_file_name(const ::std::string& value) {
  set_has_input_file_name();
  if (input_file_name_ == &::google::protobuf::internal::kEmptyString) {
    input_file_name_ = new ::std::string;
  }
  input_file_name_->assign(value);
}
inline void CameraOpt::set_input_file_name(const char* value) {
  set_has_input_file_name();
  if (input_file_name_ == &::google::protobuf::internal::kEmptyString) {
    input_file_name_ = new ::std::string;
  }
  input_file_name_->assign(value);
}
inline void CameraOpt::set_input_file_name(const char* value, size_t size) {
  set_has_input_file_name();
  if (input_file_name_ == &::google::protobuf::internal::kEmptyString) {
    input_file_name_ = new ::std::string;
  }
  input_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CameraOpt::mutable_input_file_name() {
  set_has_input_file_name();
  if (input_file_name_ == &::google::protobuf::internal::kEmptyString) {
    input_file_name_ = new ::std::string;
  }
  return input_file_name_;
}
inline ::std::string* CameraOpt::release_input_file_name() {
  clear_has_input_file_name();
  if (input_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = input_file_name_;
    input_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string output_file_name = 4;
inline bool CameraOpt::has_output_file_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraOpt::set_has_output_file_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraOpt::clear_has_output_file_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraOpt::clear_output_file_name() {
  if (output_file_name_ != &::google::protobuf::internal::kEmptyString) {
    output_file_name_->clear();
  }
  clear_has_output_file_name();
}
inline const ::std::string& CameraOpt::output_file_name() const {
  return *output_file_name_;
}
inline void CameraOpt::set_output_file_name(const ::std::string& value) {
  set_has_output_file_name();
  if (output_file_name_ == &::google::protobuf::internal::kEmptyString) {
    output_file_name_ = new ::std::string;
  }
  output_file_name_->assign(value);
}
inline void CameraOpt::set_output_file_name(const char* value) {
  set_has_output_file_name();
  if (output_file_name_ == &::google::protobuf::internal::kEmptyString) {
    output_file_name_ = new ::std::string;
  }
  output_file_name_->assign(value);
}
inline void CameraOpt::set_output_file_name(const char* value, size_t size) {
  set_has_output_file_name();
  if (output_file_name_ == &::google::protobuf::internal::kEmptyString) {
    output_file_name_ = new ::std::string;
  }
  output_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CameraOpt::mutable_output_file_name() {
  set_has_output_file_name();
  if (output_file_name_ == &::google::protobuf::internal::kEmptyString) {
    output_file_name_ = new ::std::string;
  }
  return output_file_name_;
}
inline ::std::string* CameraOpt::release_output_file_name() {
  clear_has_output_file_name();
  if (output_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = output_file_name_;
    output_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .OrthoConv ortho_conv = 5;
inline bool CameraOpt::has_ortho_conv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CameraOpt::set_has_ortho_conv() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CameraOpt::clear_has_ortho_conv() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CameraOpt::clear_ortho_conv() {
  if (ortho_conv_ != NULL) ortho_conv_->::OrthoConv::Clear();
  clear_has_ortho_conv();
}
inline const ::OrthoConv& CameraOpt::ortho_conv() const {
  return ortho_conv_ != NULL ? *ortho_conv_ : *default_instance_->ortho_conv_;
}
inline ::OrthoConv* CameraOpt::mutable_ortho_conv() {
  set_has_ortho_conv();
  if (ortho_conv_ == NULL) ortho_conv_ = new ::OrthoConv;
  return ortho_conv_;
}
inline ::OrthoConv* CameraOpt::release_ortho_conv() {
  clear_has_ortho_conv();
  ::OrthoConv* temp = ortho_conv_;
  ortho_conv_ = NULL;
  return temp;
}

// optional .Affine2D affine_2d = 6;
inline bool CameraOpt::has_affine_2d() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CameraOpt::set_has_affine_2d() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CameraOpt::clear_has_affine_2d() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CameraOpt::clear_affine_2d() {
  if (affine_2d_ != NULL) affine_2d_->::Affine2D::Clear();
  clear_has_affine_2d();
}
inline const ::Affine2D& CameraOpt::affine_2d() const {
  return affine_2d_ != NULL ? *affine_2d_ : *default_instance_->affine_2d_;
}
inline ::Affine2D* CameraOpt::mutable_affine_2d() {
  set_has_affine_2d();
  if (affine_2d_ == NULL) affine_2d_ = new ::Affine2D;
  return affine_2d_;
}
inline ::Affine2D* CameraOpt::release_affine_2d() {
  clear_has_affine_2d();
  ::Affine2D* temp = affine_2d_;
  affine_2d_ = NULL;
  return temp;
}

// optional .ProjMat proj_mat = 7;
inline bool CameraOpt::has_proj_mat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CameraOpt::set_has_proj_mat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CameraOpt::clear_has_proj_mat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CameraOpt::clear_proj_mat() {
  if (proj_mat_ != NULL) proj_mat_->::ProjMat::Clear();
  clear_has_proj_mat();
}
inline const ::ProjMat& CameraOpt::proj_mat() const {
  return proj_mat_ != NULL ? *proj_mat_ : *default_instance_->proj_mat_;
}
inline ::ProjMat* CameraOpt::mutable_proj_mat() {
  set_has_proj_mat();
  if (proj_mat_ == NULL) proj_mat_ = new ::ProjMat;
  return proj_mat_;
}
inline ::ProjMat* CameraOpt::release_proj_mat() {
  clear_has_proj_mat();
  ::ProjMat* temp = proj_mat_;
  proj_mat_ = NULL;
  return temp;
}

// optional int32 led_blur1 = 8;
inline bool CameraOpt::has_led_blur1() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CameraOpt::set_has_led_blur1() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CameraOpt::clear_has_led_blur1() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CameraOpt::clear_led_blur1() {
  led_blur1_ = 0;
  clear_has_led_blur1();
}
inline ::google::protobuf::int32 CameraOpt::led_blur1() const {
  return led_blur1_;
}
inline void CameraOpt::set_led_blur1(::google::protobuf::int32 value) {
  set_has_led_blur1();
  led_blur1_ = value;
}

// optional float led_threshold = 9;
inline bool CameraOpt::has_led_threshold() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CameraOpt::set_has_led_threshold() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CameraOpt::clear_has_led_threshold() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CameraOpt::clear_led_threshold() {
  led_threshold_ = 0;
  clear_has_led_threshold();
}
inline float CameraOpt::led_threshold() const {
  return led_threshold_;
}
inline void CameraOpt::set_led_threshold(float value) {
  set_has_led_threshold();
  led_threshold_ = value;
}

// optional int32 led_blur2 = 10;
inline bool CameraOpt::has_led_blur2() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CameraOpt::set_has_led_blur2() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CameraOpt::clear_has_led_blur2() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CameraOpt::clear_led_blur2() {
  led_blur2_ = 0;
  clear_has_led_blur2();
}
inline ::google::protobuf::int32 CameraOpt::led_blur2() const {
  return led_blur2_;
}
inline void CameraOpt::set_led_blur2(::google::protobuf::int32 value) {
  set_has_led_blur2();
  led_blur2_ = value;
}

// optional int32 body_blur1 = 11;
inline bool CameraOpt::has_body_blur1() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CameraOpt::set_has_body_blur1() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CameraOpt::clear_has_body_blur1() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CameraOpt::clear_body_blur1() {
  body_blur1_ = 0;
  clear_has_body_blur1();
}
inline ::google::protobuf::int32 CameraOpt::body_blur1() const {
  return body_blur1_;
}
inline void CameraOpt::set_body_blur1(::google::protobuf::int32 value) {
  set_has_body_blur1();
  body_blur1_ = value;
}

// optional float body_threshold = 12;
inline bool CameraOpt::has_body_threshold() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CameraOpt::set_has_body_threshold() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CameraOpt::clear_has_body_threshold() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CameraOpt::clear_body_threshold() {
  body_threshold_ = 0;
  clear_has_body_threshold();
}
inline float CameraOpt::body_threshold() const {
  return body_threshold_;
}
inline void CameraOpt::set_body_threshold(float value) {
  set_has_body_threshold();
  body_threshold_ = value;
}

// optional int32 body_blur2 = 13;
inline bool CameraOpt::has_body_blur2() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CameraOpt::set_has_body_blur2() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CameraOpt::clear_has_body_blur2() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CameraOpt::clear_body_blur2() {
  body_blur2_ = 0;
  clear_has_body_blur2();
}
inline ::google::protobuf::int32 CameraOpt::body_blur2() const {
  return body_blur2_;
}
inline void CameraOpt::set_body_blur2(::google::protobuf::int32 value) {
  set_has_body_blur2();
  body_blur2_ = value;
}

// optional int32 led_diameter_px = 14;
inline bool CameraOpt::has_led_diameter_px() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CameraOpt::set_has_led_diameter_px() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CameraOpt::clear_has_led_diameter_px() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CameraOpt::clear_led_diameter_px() {
  led_diameter_px_ = 0;
  clear_has_led_diameter_px();
}
inline ::google::protobuf::int32 CameraOpt::led_diameter_px() const {
  return led_diameter_px_;
}
inline void CameraOpt::set_led_diameter_px(::google::protobuf::int32 value) {
  set_has_led_diameter_px();
  led_diameter_px_ = value;
}

// optional bool background_subtract = 15;
inline bool CameraOpt::has_background_subtract() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CameraOpt::set_has_background_subtract() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CameraOpt::clear_has_background_subtract() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CameraOpt::clear_background_subtract() {
  background_subtract_ = false;
  clear_has_background_subtract();
}
inline bool CameraOpt::background_subtract() const {
  return background_subtract_;
}
inline void CameraOpt::set_background_subtract(bool value) {
  set_has_background_subtract();
  background_subtract_ = value;
}

// -------------------------------------------------------------------

// CameraGroup

// repeated .CameraOpt cam = 1;
inline int CameraGroup::cam_size() const {
  return cam_.size();
}
inline void CameraGroup::clear_cam() {
  cam_.Clear();
}
inline const ::CameraOpt& CameraGroup::cam(int index) const {
  return cam_.Get(index);
}
inline ::CameraOpt* CameraGroup::mutable_cam(int index) {
  return cam_.Mutable(index);
}
inline ::CameraOpt* CameraGroup::add_cam() {
  return cam_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CameraOpt >&
CameraGroup::cam() const {
  return cam_;
}
inline ::google::protobuf::RepeatedPtrField< ::CameraOpt >*
CameraGroup::mutable_cam() {
  return &cam_;
}

// optional .CameraGroup.CombineStyle combine = 2;
inline bool CameraGroup::has_combine() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraGroup::set_has_combine() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraGroup::clear_has_combine() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraGroup::clear_combine() {
  combine_ = 1;
  clear_has_combine();
}
inline ::CameraGroup_CombineStyle CameraGroup::combine() const {
  return static_cast< ::CameraGroup_CombineStyle >(combine_);
}
inline void CameraGroup::set_combine(::CameraGroup_CombineStyle value) {
  GOOGLE_DCHECK(::CameraGroup_CombineStyle_IsValid(value));
  set_has_combine();
  combine_ = value;
}

// optional string label = 3;
inline bool CameraGroup::has_label() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraGroup::set_has_label() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraGroup::clear_has_label() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraGroup::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& CameraGroup::label() const {
  return *label_;
}
inline void CameraGroup::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void CameraGroup::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void CameraGroup::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CameraGroup::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* CameraGroup::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Led

// optional float x_pos = 1;
inline bool Led::has_x_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Led::set_has_x_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Led::clear_has_x_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Led::clear_x_pos() {
  x_pos_ = 0;
  clear_has_x_pos();
}
inline float Led::x_pos() const {
  return x_pos_;
}
inline void Led::set_x_pos(float value) {
  set_has_x_pos();
  x_pos_ = value;
}

// optional float y_pos = 2;
inline bool Led::has_y_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Led::set_has_y_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Led::clear_has_y_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Led::clear_y_pos() {
  y_pos_ = 0;
  clear_has_y_pos();
}
inline float Led::y_pos() const {
  return y_pos_;
}
inline void Led::set_y_pos(float value) {
  set_has_y_pos();
  y_pos_ = value;
}

// optional float z_pos = 3;
inline bool Led::has_z_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Led::set_has_z_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Led::clear_has_z_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Led::clear_z_pos() {
  z_pos_ = 0;
  clear_has_z_pos();
}
inline float Led::z_pos() const {
  return z_pos_;
}
inline void Led::set_z_pos(float value) {
  set_has_z_pos();
  z_pos_ = value;
}

// -------------------------------------------------------------------

// TrackerOpt

// repeated .CameraGroup group = 1;
inline int TrackerOpt::group_size() const {
  return group_.size();
}
inline void TrackerOpt::clear_group() {
  group_.Clear();
}
inline const ::CameraGroup& TrackerOpt::group(int index) const {
  return group_.Get(index);
}
inline ::CameraGroup* TrackerOpt::mutable_group(int index) {
  return group_.Mutable(index);
}
inline ::CameraGroup* TrackerOpt::add_group() {
  return group_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CameraGroup >&
TrackerOpt::group() const {
  return group_;
}
inline ::google::protobuf::RepeatedPtrField< ::CameraGroup >*
TrackerOpt::mutable_group() {
  return &group_;
}

// optional int32 max_n_cams = 2;
inline bool TrackerOpt::has_max_n_cams() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrackerOpt::set_has_max_n_cams() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrackerOpt::clear_has_max_n_cams() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrackerOpt::clear_max_n_cams() {
  max_n_cams_ = 0;
  clear_has_max_n_cams();
}
inline ::google::protobuf::int32 TrackerOpt::max_n_cams() const {
  return max_n_cams_;
}
inline void TrackerOpt::set_max_n_cams(::google::protobuf::int32 value) {
  set_has_max_n_cams();
  max_n_cams_ = value;
}

// optional string timer = 3;
inline bool TrackerOpt::has_timer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrackerOpt::set_has_timer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrackerOpt::clear_has_timer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrackerOpt::clear_timer() {
  if (timer_ != &::google::protobuf::internal::kEmptyString) {
    timer_->clear();
  }
  clear_has_timer();
}
inline const ::std::string& TrackerOpt::timer() const {
  return *timer_;
}
inline void TrackerOpt::set_timer(const ::std::string& value) {
  set_has_timer();
  if (timer_ == &::google::protobuf::internal::kEmptyString) {
    timer_ = new ::std::string;
  }
  timer_->assign(value);
}
inline void TrackerOpt::set_timer(const char* value) {
  set_has_timer();
  if (timer_ == &::google::protobuf::internal::kEmptyString) {
    timer_ = new ::std::string;
  }
  timer_->assign(value);
}
inline void TrackerOpt::set_timer(const char* value, size_t size) {
  set_has_timer();
  if (timer_ == &::google::protobuf::internal::kEmptyString) {
    timer_ = new ::std::string;
  }
  timer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrackerOpt::mutable_timer() {
  set_has_timer();
  if (timer_ == &::google::protobuf::internal::kEmptyString) {
    timer_ = new ::std::string;
  }
  return timer_;
}
inline ::std::string* TrackerOpt::release_timer() {
  clear_has_timer();
  if (timer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timer_;
    timer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 n_led = 4;
inline bool TrackerOpt::has_n_led() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrackerOpt::set_has_n_led() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrackerOpt::clear_has_n_led() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrackerOpt::clear_n_led() {
  n_led_ = 0;
  clear_has_n_led();
}
inline ::google::protobuf::int32 TrackerOpt::n_led() const {
  return n_led_;
}
inline void TrackerOpt::set_n_led(::google::protobuf::int32 value) {
  set_has_n_led();
  n_led_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraGroup_CombineStyle>() {
  return ::CameraGroup_CombineStyle_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tracker_5fpb_2eproto__INCLUDED
